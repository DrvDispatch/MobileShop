/**
 * Product Seeder Service
 * 
 * Seeds demo products for tenants using the pre-generated dataset
 * from products-dataset.json (generated by bulk-import-devices.ts with Gemini AI)
 */

import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { DeviceGrade } from '../../generated/prisma/client.js';
import * as path from 'path';
import * as fs from 'fs';

// Pre-generated product dataset structure (from Gemini bulk import)
interface ProductDataset {
    brand: string;
    model: string;
    title: string;
    shortDescription: string;
    longDescription: string;
    price: number;
    compareAtPrice: number;
    storage: string;
    color: string;
    condition: string;
    deviceGrade: string;
    batteryHealth: number;
    imageUrl: string;
    seoKeywords: string[];
}

@Injectable()
export class ProductSeederService implements OnModuleInit {
    private readonly logger = new Logger(ProductSeederService.name);
    private dataset: ProductDataset[] = [];

    constructor(private prisma: PrismaService) { }

    // Load dataset on module init
    onModuleInit() {
        this.loadDataset();
    }

    // Load pre-generated dataset from JSON file
    private loadDataset() {
        // Try multiple possible paths (handles both dev and build scenarios)
        const possiblePaths = [
            // From compiled dist folder
            path.join(__dirname, '../../../scripts/products-dataset.json'),
            // For ts-node development (src folder)
            path.join(__dirname, '../../scripts/products-dataset.json'),
            // From project root
            path.join(process.cwd(), 'scripts/products-dataset.json'),
            // Direct from backend folder
            path.resolve('scripts/products-dataset.json'),
            // Windows absolute fallback
            'C:/Users/saidm/MuhsinWeb/mobile-shop/backend/scripts/products-dataset.json',
        ];

        this.logger.log('=== Product Seeder Debug ===');
        this.logger.log(`Current directory: ${process.cwd()}`);
        this.logger.log(`__dirname: ${__dirname}`);

        for (const datasetPath of possiblePaths) {
            this.logger.log(`Trying path: ${datasetPath}`);
            try {
                if (fs.existsSync(datasetPath)) {
                    this.logger.log(`Found file at: ${datasetPath}`);
                    const fileContent = fs.readFileSync(datasetPath, 'utf-8');
                    const data = JSON.parse(fileContent);

                    if (data.products && Array.isArray(data.products)) {
                        this.dataset = data.products;
                        this.logger.log(`✅ Successfully loaded ${this.dataset.length} products from products-dataset.json`);
                        this.logger.log(`Total products in file: ${data.totalProducts || 'not specified'}`);
                        return;
                    } else {
                        this.logger.warn('File found but no products array in JSON');
                    }
                }
            } catch (error) {
                this.logger.error(`Error reading ${datasetPath}: ${(error as Error).message}`);
            }
        }

        this.logger.error('❌ products-dataset.json not found in any location');
        this.dataset = [];
    }

    // Parse string device grade to enum
    private parseDeviceGrade(grade: string): DeviceGrade {
        const gradeMap: Record<string, DeviceGrade> = {
            'A+': DeviceGrade.A_PLUS,
            'A_PLUS': DeviceGrade.A_PLUS,
            'A': DeviceGrade.A,
            'B': DeviceGrade.B,
            'C': DeviceGrade.C,
        };
        return gradeMap[grade] || DeviceGrade.A;
    }

    // Seed products for a specific tenant
    async seedProducts(
        tenantId: string,
        options: { count?: number } = {}
    ): Promise<{ created: number; skipped: number; errors: string[] }> {
        // If count is 0, undefined, or null, seed ALL products
        const count = options.count && options.count > 0 ? options.count : this.dataset.length;
        const results = { created: 0, skipped: 0, errors: [] as string[] };

        this.logger.log(`=== Seed Products ===`);
        this.logger.log(`Tenant ID: ${tenantId}`);
        this.logger.log(`Requested count: ${options.count} (0 means all)`);
        this.logger.log(`Dataset length: ${this.dataset.length}`);
        this.logger.log(`Will seed: ${count} products`);

        if (this.dataset.length === 0) {
            this.logger.error('❌ No products in dataset to seed! Check if products-dataset.json loaded correctly.');
            return results;
        }

        // Ensure Phones category exists for this tenant
        let category = await this.prisma.category.findFirst({
            where: { slug: 'phones', tenantId },
        });

        if (!category) {
            category = await this.prisma.category.create({
                data: {
                    tenantId,
                    name: 'Smartphones',
                    slug: 'phones',
                    description: 'Refurbished smartphones',
                    isActive: true,
                },
            });
            this.logger.log('Created Phones category');
        }

        // Get products to seed - NO CAP, use actual requested count
        const productsToSeed = this.dataset.slice(0, count);
        this.logger.log(`Actually seeding ${productsToSeed.length} products`);

        for (const product of productsToSeed) {
            try {
                // Check if product already exists for this tenant
                const existing = await this.prisma.product.findFirst({
                    where: {
                        tenantId,
                        name: product.title,
                    },
                });

                if (existing) {
                    results.skipped++;
                    continue;
                }

                // Generate unique slug
                const slug = product.title
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-|-$/g, '')
                    + '-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 5);

                // Create product
                const created = await this.prisma.product.create({
                    data: {
                        tenantId,
                        name: product.title,
                        slug,
                        shortDescription: product.shortDescription,
                        description: product.longDescription,
                        price: product.price,
                        compareAtPrice: product.compareAtPrice,
                        condition: 'REFURBISHED',
                        brand: product.brand,
                        storage: product.storage,
                        color: product.color,
                        deviceGrade: this.parseDeviceGrade(product.deviceGrade),
                        batteryHealth: product.batteryHealth,
                        stockQty: Math.floor(Math.random() * 5) + 1,
                        isActive: true,
                        isFeatured: product.price > 600,
                        categoryId: category.id,
                    },
                });

                // Create product image if URL exists
                if (product.imageUrl) {
                    await this.prisma.productImage.create({
                        data: {
                            productId: created.id,
                            url: product.imageUrl,
                            alt: product.title,
                            isPrimary: true,
                            order: 0,
                        },
                    });
                }

                results.created++;
            } catch (error) {
                results.errors.push(`${product.title}: ${(error as Error).message}`);
            }
        }

        this.logger.log(`✅ Seeding complete: ${results.created} created, ${results.skipped} skipped`);
        return results;
    }

    // Get available products count (returns actual dataset length, no cap)
    getAvailableProductsCount(): number {
        this.logger.log(`getAvailableProductsCount called, returning: ${this.dataset.length}`);
        return this.dataset.length;
    }

    // Clear all products for a tenant
    async clearProducts(tenantId: string): Promise<{ deleted: number }> {
        // First delete all product images for this tenant's products
        const products = await this.prisma.product.findMany({
            where: { tenantId },
            select: { id: true },
        });

        const productIds = products.map(p => p.id);

        if (productIds.length > 0) {
            await this.prisma.productImage.deleteMany({
                where: { productId: { in: productIds } },
            });
        }

        // Then delete products
        const result = await this.prisma.product.deleteMany({
            where: { tenantId },
        });

        this.logger.log(`Deleted ${result.count} products for tenant ${tenantId}`);
        return { deleted: result.count };
    }
}
